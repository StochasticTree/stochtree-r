% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernel.R
\name{computeForestLeafIndices}
\alias{computeForestLeafIndices}
\title{Compute and return a vector representation of a forest's leaf predictions for
every observation in a dataset.
The vector has a "column-major" format that can be easily re-represented as
as a CSC sparse matrix: elements are organized so that the first \code{n} elements
correspond to leaf predictions for all \code{n} observations in a dataset for the
first tree in an ensemble, the next \code{n} elements correspond to predictions for
the second tree and so on. The "data" for each element corresponds to a uniquely
mapped column index that corresponds to a single leaf of a single tree (i.e.
if tree 1 has 3 leaves, its column indices range from 0 to 2, and then tree 2's
leaf indices begin at 3, etc...).
Users may pass a single dataset (which we refer to here as a "training set")
or two datasets (which we refer to as "training and test sets"). This verbiage
hints that one potential use-case for a matrix of leaf indices is to define a
ensemble-based kernel for kriging.}
\usage{
computeForestLeafIndices(bart_model, X_train, X_test = NULL, forest_num = NULL)
}
\arguments{
\item{bart_model}{Object of type \code{bartmodel} corresponding to a BART model with at least one sample}

\item{X_train}{Matrix of "training" data. In a traditional Gaussian process kriging context, this
corresponds to the observations for which outcomes are observed.}

\item{X_test}{(Optional) Matrix of "test" data. In a traditional Gaussian process kriging context, this
corresponds to the observations for which outcomes are unobserved and must be estimated
based on the kernels k(X_test,X_test), k(X_test,X_train), and k(X_train,X_train). If not provided,
this function will only compute k(X_train, X_train).}

\item{forest_num}{(Option) Index of the forest sample to use for kernel computation. If not provided,
this function will use the last forest.}
}
\value{
List of vectors. If \code{X_test = NULL}, the list contains
one vector of length \code{n_train * num_trees}, where \code{n_train = nrow(X_train)}
and \code{num_trees} is the number of trees in \code{bart_model}. If \code{X_test} is not \code{NULL},
the list contains another vector of length \code{n_test * num_trees}.
}
\description{
Compute and return a vector representation of a forest's leaf predictions for
every observation in a dataset.
The vector has a "column-major" format that can be easily re-represented as
as a CSC sparse matrix: elements are organized so that the first \code{n} elements
correspond to leaf predictions for all \code{n} observations in a dataset for the
first tree in an ensemble, the next \code{n} elements correspond to predictions for
the second tree and so on. The "data" for each element corresponds to a uniquely
mapped column index that corresponds to a single leaf of a single tree (i.e.
if tree 1 has 3 leaves, its column indices range from 0 to 2, and then tree 2's
leaf indices begin at 3, etc...).
Users may pass a single dataset (which we refer to here as a "training set")
or two datasets (which we refer to as "training and test sets"). This verbiage
hints that one potential use-case for a matrix of leaf indices is to define a
ensemble-based kernel for kriging.
}
