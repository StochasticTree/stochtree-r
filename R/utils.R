#' Preprocess a dataframe of covariate values, converting categorical variables 
#' to integers and one-hot encoding if need be. Returns a list including a 
#' matrix of preprocessed covariate values and associated tracking.
#'
#' @param input_df Dataframe of covariates. Users may pre-process any categorical 
#' variables as factors but it is not necessary.
#' @param ordered_cat_vars Vector of names of ordered categorical variables.
#' @param unordered_cat_vars Vector of names of unordered categorical variables.
#'
#' @return List with preprocessed data and details on the number of each type 
#' of variable, unique categories associated with categorical variables, and the 
#' vector of feature types needed for calls to BART and BCF.
#' @export
#'
#' @examples
#' cov_df <- data.frame(x1 = 1:5, x2 = 5:1, x3 = 6:10)
#' preprocess_list <- createForestCovariates(cov_df)
#' X <- preprocess_list$X
createForestCovariates <- function(input_df, ordered_cat_vars = NULL, unordered_cat_vars = NULL) {
    df_vars <- names(input_df)
    if (is.null(ordered_cat_vars)) ordered_cat_matches <- rep(F, length(df_vars))
    else ordered_cat_matches <- df_vars %in% ordered_cat_vars
    if (is.null(unordered_cat_vars)) unordered_cat_matches <- rep(F, length(df_vars))
    else unordered_cat_matches <- df_vars %in% unordered_cat_vars
    numeric_matches <- ((!ordered_cat_matches) & (!unordered_cat_matches))
    ordered_cat_vars <- df_vars[ordered_cat_matches]
    unordered_cat_vars <- df_vars[unordered_cat_matches]
    numeric_vars <- df_vars[numeric_matches]
    num_ordered_cat_vars <- length(ordered_cat_vars)
    num_unordered_cat_vars <- length(unordered_cat_vars)
    num_numeric_vars <- length(numeric_vars)
    if (num_ordered_cat_vars > 0) ordered_cat_df <- input_df[,ordered_cat_vars,drop=F]
    if (num_unordered_cat_vars > 0) unordered_cat_df <- input_df[,unordered_cat_vars,drop=F]
    if (num_numeric_vars > 0) numeric_df <- input_df[,numeric_vars,drop=F]
    
    # Empty outputs
    X <- double(0)
    unordered_unique_levels <- list()
    ordered_unique_levels <- list()
    feature_types <- integer(0)
    
    # Finally, extract the numeric covariates
    if (num_numeric_vars > 0) {
        Xnum <- double(0)
        for (i in 1:ncol(numeric_df)) {
            stopifnot(is.numeric(numeric_df[,i]))
            Xnum <- cbind(Xnum, numeric_df[,i])
        }
        X <- cbind(X, Xnum)
        feature_types <- c(feature_types, rep(0, ncol(Xnum)))
    }
    
    # Next, run some simple preprocessing on the ordered categorical covariates
    if (num_ordered_cat_vars > 0) {
        Xordcat <- double(0)
        for (i in 1:ncol(ordered_cat_df)) {
            var_name <- names(ordered_cat_df)[i]
            preprocess_list <- orderedCatInitializeAndPreprocess(ordered_cat_df[,i])
            ordered_unique_levels[[var_name]] <- preprocess_list$unique_levels
            Xordcat <- cbind(Xordcat, preprocess_list$x_preprocessed)
        }
        X <- cbind(X, Xordcat)
        feature_types <- c(feature_types, rep(1, ncol(Xordcat)))
    }
    
    # First, one-hot encode the unordered categorical covariates
    if (num_unordered_cat_vars > 0) {
        one_hot_mats <- list()
        for (i in 1:ncol(unordered_cat_df)) {
            var_name <- names(unordered_cat_df)[i]
            encode_list <- oneHotInitializeAndEncode(unordered_cat_df[,i])
            unordered_unique_levels[[var_name]] <- encode_list$unique_levels
            one_hot_mats[[var_name]] <- encode_list$Xtilde
        }
        Xcat <- do.call(cbind, one_hot_mats)
        X <- cbind(X, Xcat)
        feature_types <- c(feature_types, rep(1, ncol(Xcat)))
    }
    
    # Aggregate results into a list
    output <- list(
        X = X, 
        feature_types = feature_types, 
        num_ordered_cat_vars = num_ordered_cat_vars, 
        num_unordered_cat_vars = num_unordered_cat_vars, 
        num_numeric_vars = num_numeric_vars
    )
    if (num_ordered_cat_vars > 0) {
        output[["ordered_cat_vars"]] = ordered_cat_vars
        output[["ordered_unique_levels"]] = ordered_unique_levels
    }
    if (num_unordered_cat_vars > 0) {
        output[["unordered_cat_vars"]] = unordered_cat_vars
        output[["unordered_unique_levels"]] = unordered_unique_levels
    }
    if (num_numeric_vars > 0) output[["numeric_vars"]] = numeric_vars
    
    return(output)
}

#' Convert a vector of unordered categorical data (either numeric or character 
#' labels) to a "one-hot" encoded matrix in which a 1 in a column indicates 
#' the presence of the relevant category. 
#' 
#' To allow for prediction on "unseen" categories in a test dataset, this 
#' procedure pads the one-hot matrix with a blank "other" column. 
#' Test set observations that contain categories not in `levels(factor(x_input))`
#' will all be mapped to this column.
#'
#' @param x_input Vector of unordered categorical data (typically either strings 
#' integers, but this function also accepts floating point data).
#'
#' @return List containing a binary one-hot matrix and the unique levels of the 
#' input variable. These unique levels are used in the BCF and BART functions.
#' @export
#'
#' @examples
#' x <- c("a","c","b","c","d","a","c","a","b","d")
#' x_onehot <- oneHotInitializeAndEncode(x)
oneHotInitializeAndEncode <- function(x_input) {
    stopifnot((is.null(dim(x_input)) && length(x_input) > 0))
    if (is.factor(x_input) && is.ordered(x_input)) warning("One-hot encoding an ordered categorical variable")
    x_factor <- factor(x_input)
    unique_levels <- levels(x_factor)
    Xtilde <- cbind(unname(model.matrix(~0+x_factor)), 0)
    output <- list(Xtilde = Xtilde, unique_levels = unique_levels)
    return(output)
}

#' Convert a vector of unordered categorical data (either numeric or character 
#' labels) to a "one-hot" encoded matrix in which a 1 in a column indicates 
#' the presence of the relevant category. 
#' 
#' This procedure assumes that a reference set of observations for this variable 
#' (typically a training set that was used to sample a forest) has already been
#' one-hot encoded and that the unique levels of the training set variable are 
#' available (and passed as `unique_levels`). Test set observations that contain 
#' categories not in `unique_levels` will all be mapped to the last column of 
#' this matrix
#'
#' @param x_input Vector of unordered categorical data (typically either strings 
#' integers, but this function also accepts floating point data).
#' @param unique_levels Unique values of the categorical variable used to create 
#' the initial one-hot matrix (typically a training set)
#'
#' @return Binary one-hot matrix
#' @export
#'
#' @examples
#' x <- sample(1:8, 100, T)
#' x_test <- sample(1:9, 10, T)
#' x_onehot <- oneHotEncode(x_test, levels(factor(x)))
oneHotEncode <- function(x_input, unique_levels) {
    stopifnot((is.null(dim(x_input)) && length(x_input) > 0))
    stopifnot((is.null(dim(unique_levels)) && length(unique_levels) > 0))
    num_unique_levels <- length(unique_levels)
    in_sample <- x_input %in% unique_levels
    out_of_sample <- !(x_input %in% unique_levels)
    has_out_of_sample <- sum(out_of_sample) > 0
    if (has_out_of_sample) {
        x_factor_insample <- factor(x_input[in_sample], levels = unique_levels)
        Xtilde <- matrix(0, nrow = length(x_input), ncol = num_unique_levels + 1)
        Xtilde_insample <- cbind(unname(model.matrix(~0+x_factor_insample)), 0)
        Xtilde_out_of_sample <- cbind(matrix(0, nrow=sum(out_of_sample), ncol=num_unique_levels), 1)
        Xtilde[in_sample,] <- Xtilde_insample
        Xtilde[out_of_sample,] <- Xtilde_out_of_sample
    } else {
        x_factor <- factor(x_input, levels = unique_levels)
        Xtilde <- cbind(unname(model.matrix(~0+x_factor)), 0)
    }
    return(Xtilde)
}

#' Run some simple preprocessing of ordered categorical variables, converting 
#' ordered levels to integers if necessary, and storing the unique levels of a 
#' variable.
#'
#' @param x_input Vector of ordered categorical data. If the data is not already 
#' stored as an ordered factor, it will be converted to one using the default 
#' sort order.
#'
#' @return List containing a preprocessed vector of integer-converted ordered 
#' categorical observations and the unique level of the original ordered 
#' categorical feature.
#' @export
#'
#' @examples
#' x <- c("1. Strongly disagree", "3. Neither agree nor disagree", "2. Disagree", "4. Agree", "3. Neither agree nor disagree", "5. Strongly agree", "4. Agree")
#' preprocess_list <- orderedCatInitializeAndPreprocess(x)
#' x_preprocessed <- preprocess_list$x_preprocessed
orderedCatInitializeAndPreprocess <- function(x_input) {
    stopifnot((is.null(dim(x_input)) && length(x_input) > 0))
    already_ordered_factor <- (is.factor(x_input)) && (is.ordered(x_input))
    if (already_ordered_factor) {
        x_preprocessed <- as.integer(x_input)
        unique_levels <- levels(x_input)
    } else {
        x_factor <- factor(x_input, ordered = T)
        x_preprocessed <- as.integer(x_factor)
        unique_levels <- levels(x_factor)
    }
    return(list(x_preprocessed = x_preprocessed, unique_levels = unique_levels))
}

#' Run some simple preprocessing of ordered categorical variables, converting 
#' ordered levels to integers if necessary, and storing the unique levels of a 
#' variable.
#'
#' @param x_input Vector of ordered categorical data. If the data is not already 
#' stored as an ordered factor, it will be converted to one using the default 
#' sort order.
#'
#' @return List containing a preprocessed vector of integer-converted ordered 
#' categorical observations and the unique level of the original ordered 
#' categorical feature.
#' @export
#'
#' @examples
#' x_levels <- c("1. Strongly disagree", "2. Disagree", "3. Neither agree nor disagree", "4. Agree", "5. Strongly agree")
#' x <- c("1. Strongly disagree", "3. Neither agree nor disagree", "2. Disagree", "4. Agree", "3. Neither agree nor disagree", "5. Strongly agree", "4. Agree")
#' x_processed <- orderedCatPreprocess(x, x_levels)
orderedCatPreprocess <- function(x_input, unique_levels, var_name = NULL) {
    stopifnot((is.null(dim(x_input)) && length(x_input) > 0))
    stopifnot((is.null(dim(unique_levels)) && length(unique_levels) > 0))
    already_ordered_factor <- (is.factor(x_input)) && (is.ordered(x_input))
    if (already_ordered_factor) {
        # Run time checks
        levels_not_in_reflist <- !(levels(x_input) %in% unique_levels)
        if (sum(levels_not_in_reflist) > 0) {
            if (!is.null(var_name)) warning_message <- paste0("Variable ", var_name, " includes ordered categorical levels not included in the original training set")
            else warning_message <- paste0("Variable includes ordered categorical levels not included in the original training set")
            warning(warning_message)
        }
        # Preprocessing
        x_string <- as.character(x_input)
        x_factor <- factor(x_string, unique_levels, ordered = T)
        x_preprocessed <- as.integer(x_factor)
        x_preprocessed[is.na(x_preprocessed)] <- length(unique_levels) + 1
    } else {
        x_factor <- factor(x_input, ordered = T)
        # Run time checks
        levels_not_in_reflist <- !(levels(x_factor) %in% unique_levels)
        if (sum(levels_not_in_reflist) > 0) {
            if (!is.null(var_name)) warning_message <- paste0("Variable ", var_name, " includes ordered categorical levels not included in the original training set")
            else warning_message <- paste0("Variable includes ordered categorical levels not included in the original training set")
            warning(warning_message)
        }
        # Preprocessing
        x_string <- as.character(x_input)
        x_factor <- factor(x_string, unique_levels, ordered = T)
        x_preprocessed <- as.integer(x_factor)
        x_preprocessed[is.na(x_preprocessed)] <- length(unique_levels) + 1
    }
    return(x_preprocessed)
}
